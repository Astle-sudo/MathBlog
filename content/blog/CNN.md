---
title: Exploring Architectures- CNN
description: Convolutional Nerual Networks (math that gives vision)
date: 2024-01-07
---

In the essays that I have written before about Neural Networks and how they can be seen as simply an implementation of Linear Algebra and Vector calculus, I found that explaining them through this perspective exposed me to some new concepts and a new way of looking at Neural Networks. Thus followig these topics, in the upcoming essays, I will explore the different architectures of Neural Networks, following the same procedure of using only math to construct them. 
Thus in this essay, we shall explore Convolutional Neural Networks, basically the networks that give computers vision. These can be very powerful and complex (with the modern improvements and modifications), hence I shall explore only a basic convolutional neural network.

## Convolutional Neural Networks

In the <a href="/blog/nnla/">previous</a> essays, I have written about linear regression through stochastic gradient descend, which were very powerful and efficient, but only when it came to certain type of problems. Regression works well when our output is of merely one-dimension. These type of problems (where our output is one dimensional) are well suited for linear regression and the loss function we used before: mean-squared error. But that is not the case when it comes to *other* problems. Vision: we want computers to recognize images. Linear Regression can prove to be slow and inefficient, not to mention we can do better on the loss function as well. There are a few things we must clarify first: <u>color</u> of the image, how many pre-determined <u>categories</u> are there and a new <u>loss</u> function.
Since we are assuming a simple(r) network, we shall only take grayscale values (0-255) and three categories. What about the loss funtion ? Last time we used mean-squared error, which is not exactly the worst loss function to use, but there is one better, and we benefit more from using that. Let's start by defining our input !

Since our input will be an image, it will be represented by a matrix of numbers between 0 and 255, where black is 0 and white is 255, which means our raw input will be a matrix instead of a vector, unlike in linear regression. Lets us define the input as **I**.

<math display="block" class="tml-display" style="display:block math;"><mtable displaystyle="true"><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>I</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>11</mn></msub></mtd><mtd><msub><mi>i</mi><mn>12</mn></msub></mtd><mtd><msub><mi>i</mi><mn>13</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mrow><mi>n</mi><mi>m</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mo>* </mo><mi>m</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding:0.7ex 0em 0.7ex 0em;"><mrow><mi>W</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext><mi>i</mi><mtext> </mtext><mi>ϵ</mi><mtext> </mtext><mo form="prefix" stretchy="false">[</mo><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mn>255</mn><mo form="postfix" stretchy="false">]</mo></mrow></mtd></mtr></mtable></math>

This is an (*n* *x* *m*) resolution image, passed in as a matrix. If we were to follow the usual steps (discussed in<a href="/blog/nnla/">previous</a> essays) we simply multiply the input by a weight matrix, and add a bias vector/matrix to get to the output. With the addition of a hidden layer, we created a dense or deep neural network. But in this case, we are dealing with a matrix, possibly large with each value representing a pixel which contributes to a *feature* of the image (something unique to a particular class of image). A breakthrough was made, when we discovered that using convolutions (explained shortly), we can make the training much faster and efficient, greatly increasing the accuracy of our models.

## Kernels

We have the input matrix **I**. This matrix has certain features in it. Let's assume it is a picture of a dog, than some features would be an eye, ears or paws or tail. Our model , must associate each feature to the correct class of images (dog or cat or human, etc.). This is the *learning* part of the model. Given a cat, our model must identify it's most prominent features, those which set it apart from dogs or humans and associate them to the same. This indeed seems like a daunting task to do, especially for a model (they lack sophisticated brain like ours). But this is where linear algebra shows it's brilliant magic and comes to our aid, and we finish up in style with our usual gradient desecnt optimization. So what does linear algebra offer us ? In a nutshell: smaller matrices. Let me explain. Let us define a small matrix of dimensions (3 * 3), and an example matrix of random colors (20 * 20).

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>I</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>1,1</mn></msub></mtd><mtd><msub><mi>i</mi><mn>1,2</mn></msub></mtd><mtd><msub><mi>i</mi><mn>1,3</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>1,20</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>2,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>3,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>20,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>20</mn><mo>* </mo><mn>20</mn></mrow></msub><mi>K</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>11</mn></msub></mtd><mtd><msub><mi>k</mi><mn>12</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>21</mn></msub></mtd><mtd><msub><mi>k</mi><mn>22</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>23</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>31</mn></msub></mtd><mtd><msub><mi>k</mi><mn>32</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>33</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>3</mn><mo>* </mo><mn>3</mn></mrow></msub></mrow></math><br>

The smaller matrix is known as a *kernel*. The input matrix **I** simply consists of numbers ranging from 0 to 255. Applying a convolution simply means doing an **elementwise multiplication of the kernel over the submatrices of *I* of the same dimensions, and adding up the results, which effectively reduces the dimension of the resultant matrix.**. A submatrix simply means a sub-part of a larger matrix, for example :

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>I</mi><mn>1</mn></msub><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>11</mn></msub></mtd><mtd><msub><mi>i</mi><mn>12</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>21</mn></msub></mtd><mtd><msub><mi>i</mi><mn>22</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>23</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>31</mn></msub></mtd><mtd><msub><mi>i</mi><mn>32</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>33</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>3</mn><mo>* </mo><mn>3</mn></mrow></msub></mrow></math>

Is a sub-matrix of **I**. And we simply do an elementwise multiplication of this sub-matrix with our kernel. 

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>11</mn></msub></mtd><mtd><msub><mi>i</mi><mn>12</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>21</mn></msub></mtd><mtd><msub><mi>i</mi><mn>22</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>23</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>31</mn></msub></mtd><mtd><msub><mi>i</mi><mn>32</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>33</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mtext> </mtext><mo>×</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>11</mn></msub></mtd><mtd><msub><mi>k</mi><mn>12</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>21</mn></msub></mtd><mtd><msub><mi>k</mi><mn>22</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>23</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>31</mn></msub></mtd><mtd><msub><mi>k</mi><mn>32</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mn>33</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>=</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mi>c</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mo separator="true">,</mo><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mi>c</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>=</mo><mtext> </mtext><msub><mi>i</mi><mn>11</mn></msub><msub><mi>k</mi><mn>11</mn></msub><mo>+</mo><msub><mi>i</mi><mn>12</mn></msub><msub><mi>k</mi><mn>12</mn></msub><mo>+</mo><msub><mi>i</mi><mn>13</mn></msub><msub><mi>k</mi><mn>13</mn></msub><mo>+</mo><msub><mi>i</mi><mn>21</mn></msub><msub><mi>k</mi><mn>21</mn></msub><mo>+</mo><msub><mi>i</mi><mn>22</mn></msub><msub><mi>k</mi><mn>22</mn></msub><mo>+</mo><msub><mi>i</mi><mn>23</mn></msub><msub><mi>k</mi><mn>23</mn></msub><mo>+</mo><msub><mi>i</mi><mn>31</mn></msub><msub><mi>k</mi><mn>31</mn></msub><mo>+</mo><msub><mi>i</mi><mn>32</mn></msub><msub><mi>k</mi><mn>32</mn></msub><mo>+</mo><msub><mi>i</mi><mn>33</mn></msub><msub><mi>k</mi><mn>33</mn></msub></mrow></mtd></mtr></mtable></math><br>

The formula for the resultant matrix, given we have an input matrix I, and a kernel K, with their respective dimensions, the dimensions of the result of a convolution are given by:

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>d</mi><mi>i</mi><mi>m</mi><mo>=</mo><mo form="prefix" stretchy="false">(</mo><msub><mi>i</mi><mi>h</mi></msub><mo>−</mo><msub><mi>k</mi><mi>h</mi></msub><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>×</mo><mtext> </mtext><mo form="prefix" stretchy="false">(</mo><msub><mi>i</mi><mi>w</mi></msub><mo>−</mo><msub><mi>k</mi><mi>w</mi></msub><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false">)</mo></mrow></math><br>

We follow this with moving the kernel by one column and continuing the process, until we reach the end. This is the trick behind convolutional neural networks. Ok ? But *why* ? What does it exactly do ? Remember how I said that the network must be able to tell apart features that belong to a particular class of images ? Well if we select the kernel properly, it *highlights* certain features of images. For example, here is a very simple picture in our (20 * 20) grid input (forgive my lack of talent in art):

<img src='/media/pixelart2.png'>

This is a (20 * 20) image, with the white squares having value of 255, and the black ones having a value of 0. Suppose a prominent feature of the image above is it's vertical lines. Thus, we need to capture that particular feature of the image, i.e, a vertical line (or any vertical part for that matter) into a kernel. For now, let's try it out with this kernel below:

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>K</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>0.5</mn></mtd><mtd><mn>0.5</mn></mtd><mtd style="padding-right:0em;"><mn>0.5</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>3</mn><mo>* </mo><mn>3</mn></mrow></msub></mrow></math>

We do the above operation of doing elementwise multiplication of this kernel with each submatrix (remember: the matrix is full of 255's or 0's) and we end up with the following image: 

<img src='/media/afterconvo2.png'>

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>H</mi><mi>e</mi><mi>r</mi><msup><mi>e</mi><mo lspace="0em" rspace="0em" class="tml-prime">′</mo></msup><mi>s</mi><mtext> </mtext><mi>w</mi><mi>h</mi><mi>a</mi><mi>t</mi><mtext> </mtext><mi>h</mi><mi>a</mi><mi>p</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>d</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>11</mn></msub><mi>.</mi><msub><mi>k</mi><mn>11</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>12</mn></msub><mi>.</mi><msub><mi>k</mi><mn>12</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>13</mn></msub><mi>.</mi><msub><mi>k</mi><mn>13</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>21</mn></msub><mi>.</mi><msub><mi>k</mi><mn>21</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>22</mn></msub><mi>.</mi><msub><mi>k</mi><mn>22</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>23</mn></msub><mi>.</mi><msub><mi>k</mi><mn>23</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>31</mn></msub><mi>.</mi><msub><mi>k</mi><mn>31</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>32</mn></msub><mi>.</mi><msub><mi>k</mi><mn>32</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>33</mn></msub><mi>.</mi><msub><mi>k</mi><mn>33</mn></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>1,20</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>20,1</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo stretchy="false">→</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>12</mn></msub><mi>.</mi><msub><mi>k</mi><mn>11</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>13</mn></msub><mi>.</mi><msub><mi>k</mi><mn>12</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>14</mn></msub><mi>.</mi><msub><mi>k</mi><mn>13</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>22</mn></msub><mi>.</mi><msub><mi>k</mi><mn>21</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>23</mn></msub><mi>.</mi><msub><mi>k</mi><mn>22</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>24</mn></msub><mi>.</mi><msub><mi>k</mi><mn>23</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>i</mi><mn>32</mn></msub><mi>.</mi><msub><mi>k</mi><mn>31</mn></msub></mrow></mtd><mtd><mrow><msub><mi>i</mi><mn>33</mn></msub><mi>.</mi><msub><mi>k</mi><mn>32</mn></msub></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>i</mi><mn>34</mn></msub><mi>.</mi><msub><mi>k</mi><mn>33</mn></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mtd><mtd style="padding-right:0em;"><mo lspace="0em" rspace="0em">…</mo></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>i</mi><mn>20,1</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>i</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>A</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>w</mi><mi>e</mi><mtext> </mtext><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>e</mi><mtext> </mtext><mi>t</mi><mi>i</mi><mi>l</mi><mi>l</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>d</mi></mrow></mtd></mtr></mtable></math>

**Note: The values of kernel did not change!**

It is pretty evident (and satisfying) to see what the kernel did: it sort of highlighted the vertical lines in the image! This means that the kernel **K** encaptures vertical lines in this image! Just as is the case here, every image has a unique feature which it shares with other images of the same type (every stick man has a vertical line for a torso), and thus if we correctly encapture that exact feature in a kernel, we can more easily identify a class of an image. That is the *learning* part in these networks: they learn to find a kernel which best represents a particular feature (as the above kernel represents vertical lines) except they do so taking into account *all* of the images we provide, and finds kernels which encapture features which are similiar, but also have slight variations (a dog sitting vs standing). With this, we can now finally move forward!

## Forward Propagation

After we get the convoluted matrix from the previous operations, we simply follow through with the same procedure as we did for normal neural networks: multiply by weights and add a bias term. But before we do that, let us not forget we have a matrix and not a vector. Why not convert our matrix into one than ? It makes it much simpler to deal with, as we always prefer less complicated or lower dimensional stuff ! Let **C** be the convoluted matrix.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mtext> </mtext><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>c</mi><mn>1,1</mn></msub></mtd><mtd><msub><mi>c</mi><mn>1,2</mn></msub></mtd><mtd><msub><mi>c</mi><mn>1,3</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>c</mi><mn>1,20</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>c</mi><mn>2,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>c</mi><mn>3,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>c</mi><mn>20,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>c</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>20</mn><mo>* </mo><mn>20</mn></mrow></msub><mo stretchy="false">→</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>c</mi><mn>1,1</mn></msub></mtd><mtd><msub><mi>c</mi><mn>1,2</mn></msub></mtd><mtd><msub><mi>c</mi><mn>1,3</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>c</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>20</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>a</mi><mi>l</mi><mi>s</mi><mi>o</mi><mtext> </mtext><mi>w</mi><mi>r</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>e</mi><mi>n</mi><mtext> </mtext><mi>a</mi><mi>s</mi><mtext> </mtext><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>20</mn></mrow><mi>T</mi></msubsup></mtd></mtr></mtable></math>

Now we can go ahead and use weights and biases to the convolution vector to get what we want: the output of the first "layer". Let **W** be the weight matrix and **B** be the bias vector.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>C</mi><mi>W</mi><mo>+</mo><mi>B</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mi>O</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>c</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>20</mn></mrow><mi>T</mi></msubsup><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>1,1</mn></msub></mtd><mtd><msub><mi>w</mi><mn>12</mn></msub></mtd><mtd><msub><mi>w</mi><mn>13</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>m</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>2,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>3,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>20,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mi>m</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>20</mn><mo>* </mo><mi>m</mi></mrow></msub><mo>+</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup><mo>=</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup></mrow></mtd></mtr></mtable></math>

This gives us our first output. Since I have covered this process before, in previous mentioned essays, I will only go over them briefly: we put these through an activation function, and add a hidden layer, except this time, there are new functions and dimensions to think (worry) about! Anyways, here is the ReLu activation function applied to the same:

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>R</mi><mi>e</mi><mi>L</mi><mi>u</mi><mtext> </mtext><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><mn>1</mn><mn>2</mn></mfrac><mrow><mo fence="true" form="prefix">(</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup><mo>+</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>|</mi><msub><mi>o</mi><mn>1,1</mn></msub><mi>|</mi></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>|</mi><msub><mi>o</mi><mn>1,2</mn></msub><mi>|</mi></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>|</mi><msub><mi>o</mi><mn>1,3</mn></msub><mi>|</mi></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>|</mi><msub><mi>o</mi><mn>20,20</mn></msub><mi>|</mi></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup><mo fence="true" form="postfix">)</mo></mrow><mo>=</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup></mrow></math>

With this, we can finally arrive at the last problem: what will be our output exactly? Remember that this is a classification from, therefore we do not want quantity, but instead a *class* of an image (whether it is a dog, cat or human). Therefore our output must represent each of these categories. A very simple way would be to assign each label a vector, such as :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mtext> </mtext><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>D</mi><mi>o</mi><mi>g</mi><mtext> </mtext><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>H</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>n</mi><mtext> </mtext><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr></mtable></math>

With this, not only us, but even a computer model can distinguish between the three. Hence our output must be a (1 * 3) dimensional vector, with each number representing a class. With that, we can go ahead with our hidden layer, to calculate our final output. Let **W**<sub>2</sub> be the weigths and  **B**<sub>2</sub> be the bias. (With  **W**<sub>1</sub> and  **B**<sub>1</sub> being the previous ones.)

<math display="block" class="tml-display" style="display:block math;"><mrow><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>1,3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>h</mi><mn>20,20</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>m</mi></mrow><mi>T</mi></msubsup><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><msub><mi>w</mi><mn>12</mn></msub></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mn>13</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>m</mi><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>w</mi><mrow><mi>m</mi><mn>2</mn></mrow></msub></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>m</mi><mn>3</mn></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>m</mi><mo>* </mo><mn>3</mn></mrow></msub><mo>+</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>11</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>13</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>3</mn></mrow><mi>T</mi></msubsup><mo>=</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>11</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>13</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>3</mn></mrow><mi>T</mi></msubsup></mrow></math>

With this process, we finally arrive at our final answer. The logical next step would be to somehow compare this vector to whatever is the true answer, but the question is how? Do we simply subtract it and square, like in mean-squared error ? No. What we need here is probability: our model must give *probabilities* about how certain it is about the given image, and we are going to build our loss function around that as well. This is a major difference between linear regression and classification: the use of probabilities and a different loss function, so let's get started!

## Softmax Function

One problem when thinking about probabilities, is that nothing restricts our output vector from containing negative values, which can be bothersome: as there cannot be negative probability. There is also the constraint of normality: all the values in the vector must add to one. To take care of both of these problems, we pass the output through what is known as the softmax function. This particular function takes in the values and returns a probability distribution. The function is defined as :

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>S</mi><mi>o</mi><mi>f</mi><mi>t</mi><mi>m</mi><mi>a</mi><mi>x</mi><mtext> </mtext><mi>f</mi><mi>u</mi><mi>n</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><msup><mi>e</mi><msub><mi>o</mi><mi>i</mi></msub></msup><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>K</mi></msubsup><msup><mi>e</mi><msub><mi>o</mi><mi>i</mi></msub></msup></mrow></mfrac></mrow></math>

The following function works because: it takes the exponential of every term in the vector, which deals with the negative values, and it also divides with the sum total of all the exponential values of the vector elements, hence the total of the vector after softmax equals to one. Thus we must simply pass our final output into the function to get our true final probability distribution.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>σ</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>11</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>12</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>o</mi><mn>13</mn></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>3</mn></mrow><mi>T</mi></msubsup><mo fence="true" form="postfix">)</mo></mrow><mtext> </mtext><mo>=</mo><mtext> </mtext><msubsup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mfrac><msup><mi>e</mi><msub><mi>o</mi><mn>11</mn></msub></msup><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></msubsup><msup><mi>e</mi><msub><mi>o</mi><mi>i</mi></msub></msup></mrow></mfrac></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mfrac><msup><mi>e</mi><msub><mi>o</mi><mn>12</mn></msub></msup><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></msubsup><msup><mi>e</mi><msub><mi>o</mi><mi>i</mi></msub></msup></mrow></mfrac></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mfrac><msup><mi>e</mi><msub><mi>o</mi><mn>13</mn></msub></msup><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mn>3</mn></msubsup><msup><mi>e</mi><msub><mi>o</mi><mi>i</mi></msub></msup></mrow></mfrac></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mn>3</mn></mrow><mi>T</mi></msubsup></mrow></math>

**Note: The σ symbol denotes the softmax function**

Let us clearly define what we have as our final product: we have what our model thinks is the distribution of probabilities of the given image and class of categories. For example, if the vector output is [0.4, 0.3, 0.3] than the model thinks the given image is 40% human, 30% dog and 30% cat, which indicates that it is far from the true probability distribution (which could be [1,0,0] or [0,1,0] or [0,0,1]).
Our next step would be to define a loss function, but only this time, around *probabilities*.

## Cross-Entropy Loss

As mentioned above, suppose we initialze a random matrix of kernels and weights and biases, and go through the above mentioned processes to get a final probability distribution. Let's take an example of [0.2, 0.5, 0.3] as our model's initial guess. Let's assume the image was of a human, so the actual probability distribution is [1,0,0]. What we need now, is to somehow calculate the *distance* between these two distributions, or **how wrong** was the model's guess. Doing so can be a bit unintuitive, as opposed to the mean squared error. What we start with to get to our loss function is a way to find the distance or difference between two distributions, which can be calculated by using the <i>Kullback-Leibler Divergence</i>, which in statistical theory is used to find the distance of errors between probability distributions. 

### Kullback-Leibler Divergence

Let's assume we have two coins. Coin 1 has a *p*<sub>1</sub> probability of giving heads and *p*<sub>2</sub> for tails, whereas Coin 2 has a probability of *q*<sub>1</sub> for heads and *q*<sub>2</sub> for tails. Therefore their distribution can be simply given by :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>C</mi><mi>o</mi><mi>i</mi><mi>n</mi><mtext> </mtext><mn>1</mn><mtext> </mtext><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><msubsup><mi>p</mi><mn>1</mn><mi>H</mi></msubsup><mi>.</mi><msubsup><mi>p</mi><mn>2</mn><mi>T</mi></msubsup></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>C</mi><mi>o</mi><mi>i</mi><mi>n</mi><mtext> </mtext><mn>2</mn><mtext> </mtext><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><msubsup><mi>q</mi><mn>1</mn><mi>H</mi></msubsup><mi>.</mi><msubsup><mi>q</mi><mn>2</mn><mi>T</mi></msubsup></mrow></mtd></mtr></mtable></math>

Where H is the number of heads and T is the number of tails (giving H+T as the total number of tosses or *N*). What we do next is very simple: get their ratio. And since we cannot forget the normalization condition, we must take the root to the *Nth* power. Giving our final equation the form of : 

<math display="block" class="tml-display" style="display:block math;"><msup><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><msubsup><mi>p</mi><mn>1</mn><mi>H</mi></msubsup><mi>.</mi><msubsup><mi>p</mi><mn>2</mn><mi>T</mi></msubsup></mrow><mrow><msubsup><mi>q</mi><mn>1</mn><mi>H</mi></msubsup><mi>.</mi><msubsup><mi>q</mi><mn>2</mn><mi>T</mi></msubsup></mrow></mfrac><mo fence="true" form="postfix">)</mo></mrow><mfrac><mn>1</mn><mi>N</mi></mfrac></msup></math>

Believe it or not, we have already arrived at the KL divergence! Now we only have to simplify the equation by taking the log of the equation, and get to the final form. 

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><msubsup><mi>p</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mi>.</mi><msubsup><mi>p</mi><mn>2</mn><mfrac><mi>T</mi><mi>N</mi></mfrac></msubsup></mrow><mrow><msubsup><mi>q</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mi>.</mi><msubsup><mi>q</mi><mn>2</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup></mrow></mfrac><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>p</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mi>.</mi><msubsup><mi>p</mi><mn>2</mn><mfrac><mi>T</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow><mo>−</mo><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>q</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mi>.</mi><msubsup><mi>q</mi><mn>2</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>p</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow><mtext> </mtext><mo>+</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>p</mi><mn>2</mn><mfrac><mi>T</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow><mtext> </mtext><mo>−</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>q</mi><mn>1</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow><mtext> </mtext><mo>+</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msubsup><mi>q</mi><mn>2</mn><mfrac><mi>H</mi><mi>N</mi></mfrac></msubsup><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mfrac><mi>H</mi><mi>N</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mfrac><mi>T</mi><mi>N</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mfrac><mi>H</mi><mi>N</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mfrac><mi>T</mi><mi>N</mi></mfrac><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>

As N approaches infinity, *H/N* approaches *p*<sub>1</sub> and *T/N* approaches *p*<sub>2</sub> making our equations to be :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mi>p</mi><mn>1</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msub><mi>q</mi><mn>1</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msub><mi>q</mi><mn>2</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mi>p</mi><mn>1</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msub><mi>p</mi><mn>1</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>p</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msub><mi>p</mi><mn>2</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>q</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>
<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>p</mi><mn>1</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msub><mi>p</mi><mn>1</mn></msub><msub><mi>q</mi><mn>1</mn></msub></mfrac><mo fence="true" form="postfix">)</mo></mrow><mo>+</mo><msub><mi>p</mi><mn>2</mn></msub><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msub><mi>p</mi><mn>2</mn></msub><msub><mi>q</mi><mn>2</mn></msub></mfrac><mo fence="true" form="postfix">)</mo></mrow></mrow></math>

Hence we have arrived at our final equations, where given the probabilities of two different distributions, we can effectively quantify the *difference* between them, or how similiar they are. This formula can be applied to more than two probabilities as well, which gives us the technically accurate term for the KL divergence: 

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mo form="prefix" stretchy="false">(</mo><mi>P</mi><mi>|</mi><mi>|</mi><mi>Q</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>=</mo><mtext> </mtext><mrow><munder><mo movablelimits="false">∑</mo><mi>i</mi></munder></mrow><msub><mi>P</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msub><mi>P</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub><msub><mi>Q</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>i</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub></mfrac><mo fence="true" form="postfix">)</mo></mrow></mrow></math>
<br>
<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>F</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>c</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>o</mi><mi>u</mi><mi>s</mi><mtext> </mtext><mi>d</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>b</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>s</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mo form="prefix" stretchy="false">(</mo><mi>P</mi><mi>|</mi><mi>|</mi><mi>Q</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>=</mo><mo movablelimits="false">∫</mo><msub><mi>P</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msub><mi>P</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub><msub><mi>Q</mi><mrow><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="postfix" stretchy="false">)</mo></mrow></msub></mfrac><mo fence="true" form="postfix">)</mo></mrow><mi>d</mi><mi>x</mi></mrow></mtd></mtr></mtable></math>

Since we are only dealing with discrete distributions, you can ignore the second formula. (If anyone is interested,<a href="https://www.youtube.com/watch?v=SxGYPqCgJWM">here</a> is an excellent youtube video on the same topic!) Before we get eager and utilize this formula to calculate what we want, we must take a little detour and *derive* our loss function from the KL divergence.

### The Loss function

There is only a tiny difference between cross entropy and the KL divergence, and that is rooted in conditional probability. As mentioned before, we want to find the *true* probability distribution of a given output. Let us define paramters of our model to be 𝜃 (I am assuming just one, but they can be as many as you want). Thus our model, using these parameters, gets to a distribution through the above processes. Let this probability be, 

<math display="block" class="tml-display" style="display:block math;"><mrow><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>

Which means the probability distribution of the output, given the input and the parameter 𝜃 ([0.4,0.3,0.3] in our case). On the other side, we have the true probability distribution, which is simply the probability of the output given the input ([1,0,0] in our case).

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo></mrow></math>

We use the KL divergence on these to find how far away *P*<sup>* </sup> is from *P*, 

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>D</mi><mrow><mi>K</mi><mi>L</mi></mrow></msub><mrow><mo fence="true" form="prefix">(</mo><mi>P</mi><mi>|</mi><mi>|</mi><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo fence="true" form="postfix">)</mo></mrow><mtext> </mtext><mo>=</mo><mtext> </mtext><mrow><munder><mo movablelimits="false">∑</mo><mi>i</mi></munder></mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo></mrow><mrow><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo></mrow></mfrac><mo fence="true" form="postfix">)</mo></mrow></mrow></math>

And on further simplification we get, 

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mo movablelimits="false">∑</mo><mi>i</mi></msub><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>−</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo><mo fence="true" form="postfix">)</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mo movablelimits="false">∑</mo><mi>i</mi></msub><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>−</mo><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo><mo fence="true" form="postfix">)</mo></mrow><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><msub><mo movablelimits="false">∑</mo><mi>i</mi></msub><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>−</mo><msub><mo movablelimits="false">∑</mo><mi>i</mi></msub><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mi>P</mi><mo lspace="0em" rspace="0em">* </mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><mi>x</mi><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo><mo fence="true" form="postfix">)</mo></mrow><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>

Now we must remember the purpose of the loss function: to somehow tweak the parameter 𝜃, so as to decrease the loss function. Hence, we only care about the part of the equation that we can control, or the part with 𝜃 in it. Upon closer inspection, we see that the first half of the equation has no 𝜃, and thus we can completely ignore it to finally arrive at our loss function: the cross-entropy loss.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>C</mi><mi>r</mi><mi>o</mi><mi>s</mi><mi>s</mi><mtext> </mtext><mi>E</mi><mi>n</mi><mi>t</mi><mi>r</mi><mi>o</mi><mi>p</mi><mi>y</mi><mtext> </mtext><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mo>−</mo><mrow><munder><mo movablelimits="false">∑</mo><mi>i</mi></munder></mrow><mi>P</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><msub><mi>x</mi><mi>i</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>l</mi><mi>o</mi><mi>g</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mi>P</mi><mo lspace="0em" rspace="0em">*</mo></msup><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mi>|</mi><msub><mi>x</mi><mi>i</mi></msub><mo separator="true">;</mo><mi>θ</mi><mo form="postfix" stretchy="false">)</mo><mo fence="true" form="postfix">)</mo></mrow><mo form="postfix" stretchy="false">)</mo></mrow></math>

We shall continue with backpropagation in the next essay, or else this essay will be too long (scrolling is not that fun after a point), follow the link below for part II.

<p style="text-align: center;">
<i><a href="/blog/cnn2/">Continure Reading</a></i>
<br>
<strong><a href='/'>Home</a></strong>
</p>

