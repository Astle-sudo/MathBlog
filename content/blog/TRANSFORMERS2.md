---
title: Exploring architectures- Transformers II
description: A match made in heaven, keys and values
---

## Queries, Keys and Values

The most important concept that the attention mechanism introduces is familiar with the computer science community since ages: that of queries, keys and values. Note: whenever I say token, I am referring to either a word or a letter, something that needs to be predicted/generated. Each token has it's own query, keys and values, which are used to calculate it's self-attention weights, essentially a matrix/vector that captures it's relation with every other token. These are than used to either decode (in case of translation) or generate other tokens. Before going through the calculation of these weights, let us declare important weight matrices. These are used to calculate the Query, Key and Value for each token. The same weight matrices are used on every token.

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mrow><msub><mi>𝐖</mi><mi>𝐕</mi></msub><mo>=</mo><msub><mi>𝐖</mi><mi>𝐊</mi></msub><mo>=</mo><mi>𝐖</mi></mrow><mi>𝐐</mi></msub><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>d</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>d</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>d</mi><mi>d</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>d</mi><mi>x</mi><mi>d</mi></mrow></msub></mrow></math>

The forward propagation is fairly easy: each token's query is used to get the dot product similiarity between that query and the keys of all other tokens, and the resultant vector will be used with the value matrix of that token to get the self-attention weights of the token. this would conclude the weight calculation. In order to further predict or generate, we simply pass the desired weights through a dense network to get our output. The details of these operations would be discussed below. Let us begin with calculating the Query, Key and Value matrix for each token, by matrix multiplication with the addition of our input matrix and the positional matrix, **X+P**. Remember, **X** has *n* tokens, each of which is represented by a *d*-dimensional vector. Hence it's dimensions are *(n x d).*

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>𝐐</mi><mo>=</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐐</mi></msub></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>𝐊</mi><mo>=</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐊</mi></msub></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>𝐕</mi><mo>=</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐕</mi></msub></mrow></mtd></mtr></mtable></math>

<img src='/media/qkv.png'>

The next step would be to get the dot product attention between the Query matrix and the Key matrix. Here we perform a batch matrix multiplication between the Query and the Key matrix to get the similiarity values of every token with every other token, essentially giving us an *n x n* matrix.

<math display="block" class="tml-display" style="display:block math;"><mrow><msup><mrow><mi>𝐐</mi><mi>𝐊</mi></mrow><mi>𝐓</mi></msup><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>q</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>q</mi><mrow><mn>1</mn><mi>d</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>q</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>q</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>q</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>q</mi><mrow><mi>n</mi><mi>d</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mi>x</mi><mi>d</mi></mrow></msub><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>k</mi><mrow><mi>d</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>k</mi><mrow><mi>d</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>d</mi><mi>x</mi><mi>n</mi></mrow></msub></mrow></math>

Before we multiply with the value matrix, we scale this matrix with *1/srqt(d)*, to bring the overall variance to one and apply the softmax operation in order to limit the values within a probability distribution. Further, we simply multiply the resultant matrix with the Value matrix. This gives us the self-attention weight matrix, which captures the relationship between all the tokens, be it letters or be it words. (ϕ denotes the softmax function).

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msup><mrow><mi>𝐐</mi><mi>𝐊</mi></mrow><mi>𝐓</mi></msup><msqrt><mi>d</mi></msqrt></mfrac><mo fence="true" form="postfix">)</mo></mrow><mi>𝐕</mi></mrow></math>

Going forward, we also add back the input, essentially as a residual connection.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msup><mrow><mi>𝐐</mi><mi>𝐊</mi></mrow><mi>𝐓</mi></msup><msqrt><mi>d</mi></msqrt></mfrac><mo fence="true" form="postfix">)</mo></mrow><mi>𝐕</mi><mo>+</mo><mi>𝐗</mi></mrow></math>

This is to be followed by layer normalisation. In the transformer, the process of addition of residual connection and the layer normalisation happnens in the same layer, known as an AddNorm layer. (The normalisation happens layer-wise, that is, row wise).

<math display="block" class="tml-display" style="display:block math;"><mfrac><mrow><mrow><mo fence="true" form="prefix">(</mo><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><msup><mrow><mi>𝐐</mi><mi>𝐊</mi></mrow><mi>𝐓</mi></msup><msqrt><mi>d</mi></msqrt></mfrac><mo fence="true" form="postfix">)</mo></mrow><mi>𝐕</mi><mo>+</mo><mi>𝐗</mi><mo fence="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></math>

At this stage, it would help for us to visualise the above given equation purely in terms of the weight paramters and the input:

<math display="block" class="tml-display" style="display:block math;"><mfrac><mrow><mrow><mo fence="true" form="prefix">(</mo><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><mo form="prefix" stretchy="false" lspace="0em" rspace="0em">(</mo><mrow><mo form="prefix" stretchy="false" lspace="0em" rspace="0em">(</mo><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><msub><mi>𝐖</mi><mi>𝐐</mi></msub><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mo form="prefix" stretchy="false">(</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐊</mi></msub><msup><mo form="postfix" stretchy="false">)</mo><mi>𝐓</mi></msup></mrow><msqrt><mi>d</mi></msqrt></mfrac><mo fence="true" form="postfix">)</mo></mrow><mo form="prefix" stretchy="false">(</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐕</mi></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>𝐗</mi><mo fence="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac></math>

<strong>NOTE: If terms like layer normalisation, residual connection or positional encoding seem unfamiliar, read the <u><a href="/blog/transformers/">previous</a></u> essay.</strong>

## Getting the output 

At the end of the last step, the addnorm layer, we do not yet have our final output. Remember: we need a *d*-dimensional vector, which represents a token to be generated or predicted at the end, and we have a *n x d* dimensional matrix. Thus we need to pass this matrix through a dense neural network in order to get to our final output, which just means multiplying the matrix with another weight matrix. The weight matrix could be of dimensions *(d * v)*, where *v* is the vocabalry size. (Vocabulary size just refers to the size of a dictionary object, which indexes the entire corpus of tokens used). Thus we are left with :

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>𝐖</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>d</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>d</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>d</mi><mi>x</mi><mi>v</mi></mrow></msub></mrow></math>
<math display="block" class="tml-display" style="display:block math;"><mrow><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><mrow><mo fence="true" form="prefix">(</mo><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mfrac><mrow><mo form="prefix" stretchy="false" lspace="0em" rspace="0em">(</mo><mrow><mo form="prefix" stretchy="false" lspace="0em" rspace="0em">(</mo><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><msub><mi>𝐖</mi><mi>𝐐</mi></msub><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mo form="prefix" stretchy="false">(</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐊</mi></msub><msup><mo form="postfix" stretchy="false">)</mo><mi>𝐓</mi></msup></mrow><msqrt><mi>d</mi></msqrt></mfrac><mo fence="true" form="postfix">)</mo></mrow><mo form="prefix" stretchy="false">(</mo><mo form="prefix" stretchy="false">(</mo><msub><mrow><mi>𝐗</mi><mo>+</mo><mi>𝐏</mi><mo form="postfix" stretchy="false">)</mo><mi>𝐖</mi></mrow><mi>𝐕</mi></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>𝐗</mi><mo fence="true" form="postfix">)</mo></mrow><mo>−</mo><mi>μ</mi></mrow><mi>σ</mi></mfrac><mo fence="true" form="postfix">)</mo></mrow><mi>𝐖</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mn>1</mn><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mi>n</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mi>x</mi><mi>v</mi></mrow></msub></mrow></math>

The output matrix (let's call it **O**) is of the dimensions *n x v* because: there are *n* tokens and the size of the vocabalury object is *v*. The output has the prediction of the token that comes *after* the nth token, for example, the first token in **O** is the one that the model predicted should come after the first token in **X**, and so on. The generated token at the last, or the *nth* token in **O** is the one that comes after the *nth* token in **X**, and hence the true predicted token. The previous tokens are predicted in order to compare it with the actual tokens, and learn from the errors. These predicted tokens are now to be compared with the actual tokens. During the training process (as you may have guessed), we stop one token before the last, in order to learn the gradients, as the last token would be the true value that the *nth* token in **O** will be compared with.

## Loss function

Since the cross entropy loss is taken to be between the predicted *probability distribution* and the true *probability distribution*, we must pass our matrix through a softmax function, but applied across each rows, in order to constrain them in a distribution, which is to be compared with **T**, the true probability distribution. (It's rows have the one-hot encodings of the actual tokens used).

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>𝐎</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>11</mn></msub></mtd><mtd><msub><mi>o</mi><mn>12</mn></msub></mtd><mtd><msub><mi>o</mi><mn>13</mn></msub></mtd><mtd><mo>…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mn>1</mn><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>21</mn></msub></mtd><mtd><msub><mi>o</mi><mn>22</mn></msub></mtd><mtd><msub><mi>o</mi><mn>23</mn></msub></mtd><mtd><mo>…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mn>2</mn><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mn>31</mn></msub></mtd><mtd><msub><mi>o</mi><mn>32</mn></msub></mtd><mtd><msub><mi>o</mi><mn>33</mn></msub></mtd><mtd><mo>…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mn>3</mn><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>ϕ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>o</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><msub><mi>o</mi><mrow><mi>n</mi><mn>2</mn></mrow></msub></mtd><mtd><msub><mi>o</mi><mrow><mi>n</mi><mn>3</mn></mrow></msub></mtd><mtd><mo>…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>o</mi><mrow><mi>n</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mi>x</mi><mi>v</mi></mrow></msub><mi>𝐓</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>t</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>t</mi><mrow><mn>1</mn><mi>v</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>t</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>t</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>t</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>t</mi><mrow><mi>n</mi><mi>v</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mi>x</mi><mi>v</mi></mrow></msub></mrow></math>

We take the cross-entropy loss between each row (this these are the distributions) and than simply take the means of the resultant loss vector to finally get to the *Loss*, which can be backpropgated with.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>𝐋</mi><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐭</mi><mn>1</mn></msub><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐨</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>v</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐭</mi><mn>2</mn></msub><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐨</mi><mn>2</mn></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>v</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐭</mi><mn>3</mn></msub><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐨</mi><mn>3</mn></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>v</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐭</mi><mi>n</mi></msub><mo>×</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>𝐨</mi><mi>n</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>v</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>n</mi><mi>x</mi><mn>1</mn></mrow></msub></mrow></math>

Summing across the column, and dividing by it's length, we get the final loss value.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mfrac><mn>1</mn><mi>n</mi></mfrac><mrow><munderover><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover></mrow><msub><mi>𝐋</mi><mi>i</mi></msub></mrow></math>

## Backpropagation

As is the case, we shall now backpropagate through the loss function in order to calculate the gradients of each weight parameter, with respect to the loss function. Before moving on, let us ounce again look at our final loss function, in terms of only the input, true values and the weights. In case you're wondering, the first and the last vector of ones simply help in the addition of the row and column values, and reduce the matrix into a single scalar value: our loss.

<img src='/media/tl.png'>

We proceed with constructing a computational graph in order to find the gradients of these weights: **W<sub>**Q**</sub>**, **W<sub>**K**</sub>**, **W<sub>**V**</sub>** and **W**, which are:

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>δ</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow><mrow><mi>δ</mi><msub><mi>𝐖</mi><mi>𝐐</mi></msub></mrow></mfrac><mtext> </mtext><mfrac><mrow><mi>δ</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow><mrow><mi>δ</mi><msub><mi>𝐖</mi><mi>𝐊</mi></msub></mrow></mfrac><mtext> </mtext><mfrac><mrow><mi>δ</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow><mrow><mi>δ</mi><msub><mi>𝐖</mi><mi>𝐕</mi></msub></mrow></mfrac><mtext> </mtext><mfrac><mrow><mi>δ</mi><mi>L</mi><mi>o</mi><mi>s</mi><mi>s</mi></mrow><mrow><mi>δ</mi><mi>𝐖</mi></mrow></mfrac></mrow></math>

The graph given below traces the intermediate variables (as they would've formed in the autograd process), and makes it much easier to calculate the gradients.

<img src='/media/trans-graph.png'>

Following this backpropagation process, we trace the edges (lines) backwards to each node, and collect the subsequent gradients till we reach the desired nodes of the weights. Few points to consider in the below given equations: the matrix dimensions may not seem to align, but that's simply bacause I've calculated the gradients as is, we are free to perform any transpositions (to eventually match the dimensions of the parameters). The letters given below are simply the intermediate variables defined in the above image, I have not substituted them back to save space. With that said, here are the gradients of the four parameters:

<img src='/media/tg.png'>

## Conclusion

This is the last major architecture that is widely used in the industry. Transformers was truly a revolution in the machine/deep learning community and to our entire world: we saw a glimpse of true artificial intelligence. Although this may seem hopeful, we are still far from acheiving the goal of artificial intelligence. To someone who has read these essays simply, without any exposure to outside community, it might seem that transformers are just another form of algorithmic equations that solve some problems faced in previous one: but practical application makes all the difference. There are many more models and techniques to explore (even though they may not widely be known) and I will continue this journey to find and write about new architectures and techniques in this field. Thank you.

<p style="text-align: center;">
<strong><a href='/'>Home</a></strong>
</p>
