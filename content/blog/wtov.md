---
title: Word-to-Vector Embeddings
description: Understanding language
---

One of the biggest, if not THE biggest use cases for artificial intelligence is to mimic our language. This has been acheived to a very high extent by current state-of-the-art models like chatGPT and llama. Although these models have different architectures, knowing intuitively how these models learn to interepret language through much simpler and rudimentary models can pave the way onto learning the current most powerful ones. Before learning about said models, we must explore how exactly these models embed words, or, create internal representations of words which have some latent meaning.

## Natural Language Processing

One of the first challenges we face when dealing with language is how do we even deal with words ? Essentially, models are simply statistical techniques or algorithms, which deal with high-dimensional *numerical* data. The study of language has always been far removed from the study of mathematics. But in this case, our input **data** is language, or words itself. We must therefore find a way to *represent* words through numbers, and proceed to work with them. One such way is through what we call word embeddings(more on this later). We represent words through what we might as well call word vectors. But how do we determine what vectors at all to use ? That task is what our model must learn: representing words through vectors. The next question to answer is: *what* will the model learn exactly ? We can't induce it to learn the meaning of every word, as that task is beyond our current technology. What we can do, is use clever techniques to induce it to learn *some* meaning, of certain words. We use models for the purpose of predictions. If we utilize that fact cleverly, we can make the model learn correlation between certain words (our input) to certain meanings (*true values*).
Therefore, for the purpose of this essay, we will define our goal, and see what our model learns.

## Defining the task

The best way to understand NLP or RNNs is to make a model and go through the entire process (mathmatically). To begin, we need data. Since we have learning language as our main goal, we do have an infinite amount, but lets focus on a much narrower goal. Given a sentence, our model must predict if that sentence is positive, negative or neutral. Seems complicated ? It's really not. This particular problem is known as sentiment analysis, and is one of the first problems any beginner deep learning engineer must learn. Before we even begin defining our model through maths, we must define and preprocess our data, so we have numbers instead of words.

## Word Embeddings

Ok. Now we have a bunch of sentences. Each sentence is either positive (1), negative (-1) or neutral(0), in it's sentiment. How do we proceed ? To begin, encode every sentence in a vector. The most simplest form of encoding is simply to create a word index dictionary, where each and every word is associated with an index number, and we simply create a vector with the indexes of the words in the sentence. Here's an example below: 

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>W</mi><mi>o</mi><mi>r</mi><mi>d</mi><mtext> </mtext><mi>i</mi><mi>n</mi><mi>d</mi><mi>e</mi><mi>x</mi><mi>s</mi><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>I</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><mi>a</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mtext> </mtext><mi>c</mi><mi>a</mi><mi>t</mi><mo>=</mo><mn>3</mn><mo separator="true">,</mo><mtext> </mtext><mi>d</mi><mi>o</mi><mi>g</mi><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mtext> </mtext><mi>h</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>n</mi><mo>=</mo><mn>5</mn><mo separator="true">,</mo><mtext> </mtext><mtext> </mtext><mi>a</mi><mi>m</mi><mo>=</mo><mn>6</mn></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mi>I</mi><mtext> </mtext><mi>a</mi><mi>m</mi><mtext> </mtext><mi>a</mi><mtext> </mtext><mi>h</mi><mi>u</mi><mi>m</mi><mi>a</mi><mi>n</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>V</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center"><mtr><mtd style="padding-left:0em;"><mn>1</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>2</mn></mtd><mtd style="padding-right:0em;"><mn>5</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mi>I</mi><mtext> </mtext><mi>a</mi><mi>m</mi><mtext> </mtext><mi>a</mi><mtext> </mtext><mi>d</mi><mi>o</mi><mi>g</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>V</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center"><mtr><mtd style="padding-left:0em;"><mn>1</mn></mtd><mtd><mn>6</mn></mtd><mtd><mn>2</mn></mtd><mtd style="padding-right:0em;"><mn>4</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr></mtable></math>

This is indeed a very easy and simple way to encode our sentences and turn them into vectors. Notice, that the *sequence* of the sentences are preserved, as the model must learn that some words can only come *after* others, and vice versa. This is one of the main differences between these models and CNNS, they take sequences into account as well. The word index dictionary must have **all** the unique words that we use in our sentences. In this case, the size of the word index, or the total number of unique words we used is simply six. But in real life, there may be hundreds of thousands of words that would need to be indexed (millions if we consider larger models). Thus we first begin by taking our sentences, and indexing each and every word to create unique word vectors. Here's another example of how a vector would look like in a larger dataset, where there are thousands of words :
 
<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>S</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mi>S</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>o</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>d</mi><mi>o</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>w</mi><mi>a</mi><mi>s</mi><mtext> </mtext><mi>m</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>f</mi><mi>i</mi><mi>e</mi><mi>d</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>V</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>e</mi><mi>n</mi><mi>c</mi><mi>o</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center center center"><mtr><mtd style="padding-left:0em;"><mn>12</mn></mtd><mtd><mn>272</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>761</mn></mtd><mtd><mn>29</mn></mtd><mtd><mn>122</mn></mtd><mtd style="padding-right:0em;"><mn>23001</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr></mtable></math>

Through the vector we can see that there must be more than 23000 words in that particular word index dictionary. Before we move on, we must not forget that each sentence that we have will be of different length. This can be a problem, as every input vector we use must be of the same length, to form a matrix (vectors of different lengths can't form a matrix can they?). A simple way around this problem is to apply *padding*, take the length of the largest vector/sentence (or set one maximum length yourself), and simply add zeros before or after the values in a vector till it reaches the desired length. For instance, if the maximum length is 10 (of the largest sentence, or the one you set), the above vector will be :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>P</mi><mi>o</mi><mi>s</mi><mi>t</mi><mo>−</mo><mi>p</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center center center center center center"><mtr><mtd style="padding-left:0em;"><mn>12</mn></mtd><mtd><mn>272</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>761</mn></mtd><mtd><mn>29</mn></mtd><mtd><mn>122</mn></mtd><mtd><mn>23001</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>P</mi><mi>r</mi><mi>e</mi><mo>−</mo><mi>p</mi><mi>a</mi><mi>d</mi><mi>d</mi><mi>i</mi><mi>n</mi><mi>g</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center center center center center center"><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>12</mn></mtd><mtd><mn>272</mn></mtd><mtd><mn>3</mn></mtd><mtd><mn>761</mn></mtd><mtd><mn>29</mn></mtd><mtd><mn>122</mn></mtd><mtd style="padding-right:0em;"><mn>23001</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr></mtable></math>

## The Embedding Layer

After we get our words vectorized, we simply have to follow the usual procedure of forward propagation, with a slight twist. Let us define a weights matrix (ignoring the bias vector for simplicity). The weight matrix, **W**<sub>1</sub>, will have the following dimenions: *v* x *h*, where *v* is the length of the word index dictionary, or the total number of words we have, and *h* can be any number we want. The matrix is thus: 

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>𝐖</mi><mn>1</mn></msub><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><msub><mi>w</mi><mn>12</mn></msub></mtd><mtd><msub><mi>w</mi><mn>13</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>h</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>v</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>v</mi><mi>h</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>v</mi><mo>* </mo><mi>h</mi></mrow></msub></mrow></math>

This is our weights matrix. Each row in this matrix correspondes to each word, in short, this matrix is a collection of different vectors, each representing a word in our dictionary. At the beginning, they are random. Ounce the learning process starts, the model will tweak and change these weights to better represent the underlying meaning of the word. 

<img src='/media/wordweights.png'>

In a gist, we provide the model with a vector of sentences, each containing the indexes of the words, the model initiliazes the weights, where each word has a vector of specified dimensions (could be any number of dimenions), and we get the output. But here, we have to apply a sort of shortcut to get to our final product. We only require the rows weights of the word in the sentences, and have no use for the other word weights for that iteration. This is where the indexes in the vector come in handy. We **select the rows according to the indexes** and get to our output.
To achieve this, we can simply use a permutation of a sparse matrix, with dimensions of *h* * *v*. For example, suppose we have a bunch of sentences, with 8 words in total. We represent these, words by 1 * *h* dimensional vectors in the weight matrix, making it 8 * *h*. Next we simply utilize the indexes in our sentence *s*, to create a sparse matrix of ones, in order to get out final output of the embedding layer: a matrix of weights representing that particular sentence.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>s</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>e</mi><mtext> </mtext><mi>v</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mo>=</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><mn>3</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>5</mn></mtd><mtd><mn>7</mn></mtd><mtd style="padding-right:0em;"><mn>2</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></math><br>
<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center center center center"><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>0</mn></mtd><mtd><mn>1</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd><mn>0</mn></mtd><mtd style="padding-right:0em;"><mn>0</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>5</mn><mo>* </mo><mn>8</mn></mrow></msub><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>1,1</mn></msub></mtd><mtd><msub><mi>w</mi><mn>1,2</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mo separator="true">,</mo><mi>h</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>2,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>3,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>4,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>5,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>6,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>7,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>8,1</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>8</mn><mo separator="true">,</mo><mi>h</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mtext> </mtext><mn>8</mn><mo>* </mo><mi>h</mi></mrow></msub><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>𝟑,𝟏</mn></msub></mtd><mtd><msub><mi>w</mi><mn>𝟑,𝟐</mn></msub></mtd><mtd><msub><mi>w</mi><mn>𝟑,𝟑</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>3</mn><mo separator="true">,</mo><mi>h</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>w</mi><msub><mrow></mrow><mn>𝟏,𝟏</mn></msub></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>𝟓,𝟏</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>w</mi><msub><mrow></mrow><mn>𝟕,𝟏</mn></msub></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>𝟐,𝟏</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>2</mn><mo separator="true">,</mo><mi>h</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>5</mn><mo>* </mo><mi>h</mi></mrow></msub></mrow></math>

This is the matrix that will be passed along to the next and final layer.

## Forward Propagation

As we get our matrix, as the output from the previous layer, we must do one more thing: average the weight values. As mentioned before, each word will have a vector of certain length assigned to it. To get a good metric, we simply average these vectors, to go from 1 * *h* dimensions to a scalar, and hence reducing the matrix to a vector again. This particular step isn't necessary, but since it seems to enhance the quality of my model, I decided to include it here as well. This step is called Global Average Pooling, where we take the *average* of the values and hence *pool* together a matrix into a vector.

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>h</mi><mn>11</mn></msub></mtd><mtd><msub><mi>h</mi><mn>12</mn></msub></mtd><mtd><msub><mi>h</mi><mn>13</mn></msub></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd style="padding-right:0em;"><msub><mi>h</mi><mrow><mn>1</mn><mi>y</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>h</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>h</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>h</mi><mrow><mi>x</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo lspace="0em" rspace="0em">…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>h</mi><mrow><mi>x</mi><mi>y</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>x</mi><mo>* </mo><mi>y</mi></mrow></msub><mo stretchy="false">⇒</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>3</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>x</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>x</mi><mo>* </mo><mn>1</mn></mrow></msub></mrow></math>

Proceding further, we pass it onto the next and final layer. This remaining task is very simple: since we need a single number/scalar as our output in order to learn from the true value/sentiment of the statement, we just need to convert the vector into a scalar, i.e, just reduce it again. 

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>1</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>2</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mn>3</mn><mi>i</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>x</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mi>x</mi><mo>* </mo><mn>1</mn></mrow></msub><mo stretchy="false">⇒</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>x</mi></msubsup><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></math>

With this, we have our initial or the very first "guess" our model has provided at the ground truth, or the actual sentiment of the sentence. But before we move further, we must make it more convinient for the model to learn. Since our targets, or the actual ground truths are -1, 0 and 1, it would be better if our predictions were also between -1 and 1. Hence, as a final layer, we pass it through an activation function, known as Tanh. This function simply takes an input, and squishes it to be between -1 and 1.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>T</mi><mi>a</mi><mi>n</mi><mi>h</mi><mtext> </mtext><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow><mrow><msup><mi>e</mi><mi>x</mi></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mi>x</mi></mrow></msup></mrow></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0em 0.5ex 0em;"><mrow><mi>O</mi><mi>u</mi><mi>t</mi><mi>p</mi><mi>u</mi><mi>t</mi><mtext> </mtext><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><mrow><msup><mi>e</mi><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>x</mi></msubsup><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></msup><mo>−</mo><msup><mi>e</mi><mrow><mo>−</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>x</mi></msubsup><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></msup></mrow><mrow><msup><mi>e</mi><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>x</mi></msubsup><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></msup><mo>+</mo><msup><mi>e</mi><mrow><mo>−</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><msubsup><mo movablelimits="false">∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mi>x</mi></msubsup><msubsup><mo movablelimits="false">∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>y</mi></msubsup><msub><mi>h</mi><mrow><mi>j</mi><mi>i</mi></mrow></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></msup></mrow></mfrac></mrow></mtd></mtr></mtable></math>

With this, we finally have our output. Thus we must proceed further to perform the most important step, stochastic gradient descent or in other words, backpropagation.

<p style="text-align: center;">
<i><a href="/blog/wtov2/">Continure Reading</a></i>
<br>
<strong><a href='/'>Home</a></strong>
</p>
