---
title: Neural Ordinary Differential Equations
description: From discrete -> continuous 
---

## Introduction

As I am truly fascinated by the application of mathematics in general, I was intrigued when exposed to the field of deep learning: the amalgamation of two of my favourite fields, math and computer science. As I continued to explore, I saw the pattern of rapid evolution of computer hardware, faster algorithms and better and more powerful architectures, yet, mathematical concepts were left behind. We accelerated through GPUs and came up with more and more model architectures but the equations and algorithms were always created with computer science/applications in mind, and it was for the good as well. 

Imagine my fascination upon discovering a <strike>new</strike> novel approach to model architecture, and that finally, the ancient treasure trove of mathematics was opened again! It was a breadth of fresh air, and some heavy mathematics to tackle! And hence I am writing this essay to convey to the best of my ability what I have learned, and to do it in the most intuitive way possible. (To anyone wondering, no, I do not think the latest improvements before this concept did not utilise mathematical concepts or were math-deprived, but it was my perspective as far as I had studied ML). A warning is due in order, as this essay may get long and a familiarity with all of the previous concepts (in this blog) and rudimentory integration and differential equations is necessary.

## A <i>differential</i> approach

We begin with looking where even differential equations can be utilised in this field. Differential Equations are basically one of the most useful concepts in mathematics, physics, chemistry, biology, economics etc... basically every field that deals with *change*. 
In all *deep* neural models, the process is very simple: initialise a hidden state, perform a forward pass, and the result will be the next hidden state. Let us envelope the forward pass in a neat function *f*, which takes in the previous hidden state and the parameters (that it'll tweak) and outputs the next hidden state. We do this because different model architectures perform forward pass in different ways (which means this method can applied to any model, regardless of the architecture!).

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>h</mi><mi>t</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math>

We are missing an important (and quite a revolutionary) step here: the addition of the input back to the output. This was formerly introduced in the case of ResNets, to tackle previous problems and to better the model quality: and it worked like magic. So we add an input at the end of the forward pass to better improve the model. Why stop there, why not add the input after every block, every *layer* ? So here we are:

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>h</mi><mi>t</mi></msub><mo>+</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>h</mi><mi>t</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math>

Now comes the neat part: remember how I said differential equations study the effects of change ? (Well actually calculus itself does, anyways) If you notice, the only thing changing here is our hidden state: *h*<sub>*t*</sub>. Why not simply move it to the left side ?

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>h</mi><mi>t</mi></msub><mo>=</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>h</mi><mi>t</mi></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></math>

Here we essentially are parametrising the change in our hidden state. And a little calculus-1 helps: why not take it to the limit ? In doing so, we get the most out of the model, by simply moving from the world of discrete to the world of continuous. (Since now we are moving in a continuous fashion, we can parametrise *h* with respect to *t* or time, and write it as *h(t)*).

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>t</mi><mo stretchy="false">→</mo><mi>∞</mi></mrow></msub><mtext> </mtext><mfrac><mrow><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>−</mo><msub><mi>h</mi><mi>t</mi></msub></mrow><mi>t</mi></mfrac><mo>=</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>

Here we have our desired differential equation ! Basically this gives us the final output, which, as we know by now, must be compared with the ground truth in order to calculate our loss function ! Let *L* be our loss function (again this is left ambiguous, and any loss function can be used), *x(t<sub>0</sub>)* be our input at time *t<sub>0</sub>*, and our output will be till *t<sub>1</sub>*. The final output of a forward pass will be the "sum" of all the changes *x(t)* goes through (how the input changes after each layer) being added to our starting point, and since we are in the world of the continuous, we integrate.

<math display="block" class="tml-display" style="display:block math;"><mrow><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mfrac><mrow><mi>d</mi><mi>x</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi><mo>=</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>t</mi></mrow></math>

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>x</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>t</mi></mrow></math>

Hence is our final loss:

<math display="block" class="tml-display" style="display:block math;"><mrow><mtext>L</mtext><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><mtext>L</mtext><mrow><mo fence="true" form="prefix">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>t</mi><mo fence="true" form="postfix">)</mo></mrow></mrow></math>

My usual approach is to go through a numerical example with an input, but in this case, the theory is a tad bit different than the approach itself. The theory is quite complex and initially unintuitive (at least compared to the other models), and must be dealt with without an example first.

## Reverse Mode Automatic Differentiation: A differential approach

While we may have come up with the formulation of a differential equation and used it to parametrise our model, that was just the forward pass. As is the case in deep learning in general, the backpropagation is the main, and often the complex, part. The process of acquiring the necessary gradients from our loss function can be done in the traditional way, but turns out to be quite computationally expensive and inaccurate.
The authors of the<a href="https://arxiv.org/abs/1806.07366" target="_blank">paper</a> came up with a different approach: <i>the adjoint sensitivity method</i>. This method is not new, and was first introduced in<a href="https://www.routledge.com/Mathematical-Theory-of-Optimal-Processes/Pontryagin/p/book/9782881240775">1962</a>. The method has many similiarities with backprop, and only differs in a slight manner. 
There are a few different perspectives of understanding what we are upto here, but I would use the most straight-forward one (other perspectives may introduce certain terms which although useful, may not be relevant here).

The adjoint sensitivity method works by introducing an adjoint state, which acts as an intermediary between the Loss and other parameters we would want the gradients of. Let's say our hidden state, parametrised by time, is *h(t)*. Our adjoint state is simply the gradient of the loss with respect to this hidden state.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></math>

Here, it can also be seen as a Langrange multiplier, but why is it so, and how it can be seen as such is not necessary in this context, as it would lead to a whole new field of constrained optimization and wouldn't help us going forward. I recommend going through this<a href="https://youtu.be/nJphsM4obOk?si=TKfgVhqsL7EXY-5I" target="_blank">video</a> if anyone is interested.
Moving on, our main concern is knowing the dynamics of how the adjoint state changes, in order to solve for the gradient we are looking for. In order to get it, we simply need to remember the chain rule. Recall the chain rule in case of a discrete forward pass, and a continuous one:

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>D</mi><mi>i</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>e</mi><mi>t</mi><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><msub><mi>h</mi><mi>t</mi></msub></mrow></mfrac><mo>=</mo><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mi>e</mi></mrow></msub></mrow></mfrac><mi>.</mi><mi>.</mi><mi>.</mi><mfrac><mrow><mi>d</mi><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>3</mn></mrow></msub></mrow><mrow><mi>d</mi><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>2</mn></mrow></msub></mrow></mfrac><mfrac><mrow><mi>d</mi><msub><mi>h</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><mrow><mi>d</mi><msub><mi>h</mi><mi>t</mi></msub></mrow></mfrac><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>C</mi><mi>o</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>u</mi><mi>o</mi><mi>u</mi><mi>s</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>=</mo><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></mtd></mtr></mtable></math>

A key note to remember is the adjoint state can be defined for any function which is parametrised by time, and just in this case we are looking at the hidden state. Lets look at how our function would change after *e* time, that is, *t* -> *t+e*. We simply add the integrated differential to our initial input.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msubsup><mo movablelimits="false">∫</mo><mi>t</mi><mrow><mi>t</mi><mo>+</mo><mi>e</mi></mrow></msubsup><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>t</mi><mo>=</mo><mi>T</mi><msub><mi>h</mi><mi>t</mi></msub></mrow></math>

Let us call it *Th<sub>t</sub>* for ease of notation. We now simply plug in this equation into our previous continouos derivative (adding the partial derivative sign since the equation is multi-variate): 

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>=</mo><mtext> </mtext><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mfrac><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>=</mo><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mi>T</mi><msub><mi>h</mi><mi>t</mi></msub></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></math>

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mi>T</mi><msub><mi>h</mi><mi>t</mi></msub></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></math>

Our final goal is to find out how this adjoint state changes, basically :

<math display="block" class="tml-display" style="display:block math;"><mfrac><mrow><mi>d</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac></math>

We need this value in order to sum(integrate) over it in order to find the gradients of the loss with respect to the underlying function (we will see that later). Next we attempt to solve for the derivative using limits. 

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>T</mi><mi>a</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mtext> </mtext><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mi>T</mi><msub><mi>h</mi><mi>t</mi></msub></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>S</mi><mi>u</mi><mi>b</mi><mi>s</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>T</mi><msub><mi>h</mi><mi>t</mi></msub><mtext> </mtext><mi>w</mi><mi>i</mi><mi>t</mi><mi>h</mi><mtext> </mtext><mi>i</mi><msup><mi>t</mi><mo lspace="0em" rspace="0em" class="tml-prime">′</mo></msup><mi>s</mi><mtext> </mtext><mi>t</mi><mi>a</mi><mi>y</mi><mi>l</mi><mi>o</mi><mi>r</mi><mtext> </mtext><mi>s</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>e</mi><mi>s</mi><mtext> </mtext><mi>e</mi><mi>x</mi><mi>p</mi><mi>a</mi><mi>n</mi><mi>s</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>a</mi><mi>r</mi><mi>o</mi><mi>u</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mi>O</mi><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow><mi>d</mi><mi>e</mi><mi>n</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>s</mi><mtext> </mtext><mi>t</mi><mi>e</mi><mi>r</mi><mi>m</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>e</mi><mi>r</mi><mtext> </mtext><mi>p</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi>s</mi><mo separator="true">,</mo><mtext> </mtext><mi>w</mi><mi>h</mi><mi>i</mi><mi>c</mi><mi>h</mi><mtext> </mtext><mi>a</mi><mi>r</mi><mi>e</mi><mtext> </mtext><mi>s</mi><mi>i</mi><mi>m</mi><mi>p</mi><mi>l</mi><mi>y</mi><mtext> </mtext><mi>m</mi><mi>u</mi><mi>l</mi><mi>t</mi><mi>i</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>b</mi><mi>y</mi><mtext> </mtext><mi>h</mi><mi>i</mi><mi>g</mi><mi>h</mi><mi>e</mi><mi>r</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>p</mi><mi>o</mi><mi>w</mi><mi>e</mi><mi>r</mi><mi>s</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mrow><mo fence="true" form="prefix">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo>+</mo><mi>e</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mo>+</mo><mtext> </mtext><mrow><mi mathvariant="normal">Ο</mi></mrow><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>U</mi><mi>n</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>p</mi><mi>a</mi><mi>r</mi><mi>t</mi><mi>i</mi><mi>a</mi><mi>l</mi><mtext> </mtext><mi>d</mi><mi>e</mi><mi>r</mi><mi>i</mi><mi>v</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>s</mi><mo separator="true">,</mo><mtext> </mtext><mi>I</mi><mtext> </mtext><mi>d</mi><mi>e</mi><mi>n</mi><mi>o</mi><mi>t</mi><mi>e</mi><mi>s</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>i</mi><mi>d</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>i</mi><mi>t</mi><mi>y</mi><mtext> </mtext><mi>m</mi><mi>a</mi><mi>t</mi><mi>r</mi><mi>i</mi><mi>x</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mrow><mo fence="true" form="prefix">(</mo><mi>I</mi><mo>+</mo><mi>e</mi><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>+</mo><mrow><mi mathvariant="normal">Ο</mi></mrow><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>O</mi><mi>p</mi><mi>e</mi><mi>n</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>u</mi><mi>p</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>b</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>k</mi><mi>e</mi><mi>t</mi><mi>s</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mi>e</mi><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>+</mo><mrow><mi mathvariant="normal">Ο</mi></mrow><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>C</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mo lspace="0em" rspace="0em">−</mo><mi>e</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>+</mo><mrow><mi mathvariant="normal">Ο</mi></mrow><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>S</mi><mi>p</mi><mi>l</mi><mi>i</mi><mi>t</mi><mi>t</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>f</mi><mi>r</mi><mi>a</mi><mi>c</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mfrac><mrow><mo lspace="0em" rspace="0em">−</mo><mi>e</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow><mi>e</mi></mfrac><mo>+</mo><mfrac><mrow><mrow><mi mathvariant="normal">Ο</mi></mrow><mrow><mo fence="true" form="prefix">(</mo><msup><mi>e</mi><mn>2</mn></msup><mo fence="true" form="postfix">)</mo></mrow></mrow><mi>e</mi></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>C</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mi>l</mi><mi>l</mi><mi>e</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mtext> </mtext><mi>o</mi><mi>f</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>d</mi><mi>e</mi><mi>n</mi><mi>o</mi><mi>m</mi><mi>i</mi><mi>n</mi><mi>a</mi><mi>t</mi><mi>o</mi><mi>r</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mi>l</mi><mi>i</mi><msub><mi>m</mi><mrow><mi>e</mi><mo stretchy="false">→</mo><mn>0</mn></mrow></msub><mo>−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo>+</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mo>+</mo><mrow><mi mathvariant="normal">Ο</mi></mrow><mo form="prefix" stretchy="false">(</mo><mi>e</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>T</mi><mi>a</mi><mi>k</mi><mi>i</mi><mi>n</mi><mi>g</mi><mtext> </mtext><mi>t</mi><mi>h</mi><mi>e</mi><mtext> </mtext><mi>l</mi><mi>i</mi><mi>m</mi><mi>i</mi><mi>t</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></mtd></mtr></mtable></math>

With this straigh-forward proof, we have acquired the necessery equation in order to calculate the gradient of a function with respect to our Loss function. Recall the original definition of *a(t)*, where *t* can be any point in time. Let suppose *a(t<sub>0</sub>)* is the desired gradient:

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></math>

We solve this just as we have solved during the forward pass: simply add the integration over the differential back to the input. Except this time, we add it back to the *output*, which is *a(t<sub>N</sub>)*, and integrate not from *0* to *N* but backwards: from *N* to *0*. This can be seen as integrating backwards in time.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mi>N</mi></msub><mo form="postfix" stretchy="false">)</mo><mo>+</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mfrac><mrow><mi>d</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>a</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><mi>a</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mi>N</mi></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr></mtable></math>

It is **very important** to understand that this method and equation helps us calculate the gradient of a function with respect to the loss function. Under certain criterias, we can put in any function (paramatrised by time), get that function's adjoint state and calculate the gradients backward in time. There are essentially three variables we have: the input *x(t)*, our parameters *θ*, and the initial and end times *t<sub>0</sub>* and *t<sub>N</sub>*, so just *t*. Hence our three variables would have three differential equations, though since parameters do not change during the forward pass and we are calculating derivatives with respect to time:

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>∂</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mtext> </mtext><mfrac><mrow><mi>∂</mi><mi>t</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mn>1</mn></mrow></math>

And we can define an adjoint state for *each* variable, with their own integrals. Since the time equation and gradients aren't required in the model, I won't be going into the details. Let suppose we require the gradient of *θ(t)* at the initial time 0, hence following the above equations and remembering that the change till the final value would be zero, we get :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><msub><mi>a</mi><mi>θ</mi></msub><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mtext> </mtext><msub><mi>a</mi><mi>θ</mi></msub><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mi>N</mi></msub><mo form="postfix" stretchy="false">)</mo><mo>−</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><msub><mi>a</mi><mi>θ</mi></msub><mo form="prefix" stretchy="false">(</mo><msub><mi>t</mi><mn>0</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr></mtable></math> 

or in other words:

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>θ</mi></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></math>

With this, we have officially back propagated through the entire network! Even if the proofs and derivations were straight forward, (and hopefully intuitive), it would still be tough to see how do we implement this in practice. There are more nuances to how we actually do it, and hence we shall go over a numerical example and precisely follow the process of forward and backward porpagation to get a complete and thorough understanding of the concept.

## Solving a Neural-ODE numerically

Though the above given equations might help in understanding how we can model a neural network using differential equations, it might not be enough to build up the intuition to understand the entire *pipeline* or how an input *flows* through the model, and subsequently how we back-propagate through the network to arrive at the gradients. In order to build  stronger foundation of Neural ODEs, I would go through a numerical example in order to fully grasp this concept.
While the back-propgation method was derived in the last section, the practical implementation is handled a little differently (it could be said we build the theory in the last section, and here we apply it). Let us begin by defining our input, lets call it *y<sub>0</sub>*, which is an *n*-dimensional vector.

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>y</mi><mn>0</mn></msub><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>y</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>y</mi><mi>n</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>*</mo><mi>n</mi></mrow></msub></mrow></math>

Now we must define a function *f*, which parametrises the change in our input. In this case (and also to keep the calculations simple), I will simply utilise a dense layer :

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>y</mi><mn>0</mn></msub><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><mi>θ</mi><mo form="postfix" stretchy="false">)</mo><mo>=</mo><mi>σ</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>y</mi><mn>0</mn></msub><msub><mi>𝐖</mi><mrow><mi>n</mi><mo>* </mo><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>𝐁</mi><mrow><mn>1</mn><mo>* </mo><mi>n</mi></mrow></msub><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>w</mi><mi>h</mi><mi>e</mi><mi>r</mi><mi>e</mi><mtext> </mtext><mi>θ</mi><mo>=</mo><mo form="prefix" stretchy="false">{</mo><msub><mi>𝐖</mi><mrow><mi>n</mi><mo>* </mo><mi>n</mi></mrow></msub><mo separator="true">,</mo><mtext> </mtext><msub><mi>𝐁</mi><mrow><mi>1</mi><mo>* </mo><mi>n</mi></mrow></msub><mo form="postfix" stretchy="false">}</mo><mtext> </mtext><mi>a</mi><mi>n</mi><mi>d</mi><mtext> </mtext><mi>σ</mi><mo>=</mo><mi>R</mi><mi>e</mi><mi>L</mi><mi>U</mi></mrow></mtd></mtr></mtable></math>

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>𝐖</mi><mrow><mi>n</mi><mo>* </mo><mi>n</mi></mrow></msub><mo>=</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo separator="true">,</mo><mtext> </mtext><msub><mi>𝐁</mi><mrow><mn>1</mn><mo>* </mo><mi>n</mi></mrow></msub><mo>=</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mi>n</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></math>

In the above equation, *t* simply represents the time steps that we want the differential equation to take, and would be represented by *T+1*-dimensional vector (0-index), with equidistant points starting from 0. Since these Neural ODEs are primarily designed to model sequential data (which evolved through time), the dimensions of the input and the output remain the same, as the structure or state of the input never changes. 

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>t</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>t</mi><mn>0</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>t</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>t</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>t</mi><mi>T</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>*</mo><mo form="prefix" stretchy="false">(</mo><mi>T</mi><mo>+</mo><mn>1</mn><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></msub></mrow></math>

Our next step is to simply get to the output, which we will call *y<sub>1</sub>*. Recall from the previous sections that since we are going through *T* time steps, and in a continous manner, we shall integrate from *0 -> T*, using our function *f*, and the input *y<sub>0</sub>*.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mn>0</mn></msub><msub><mi>t</mi><mn>1</mn></msub></msubsup><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>x</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mtext> </mtext><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><msub><mi>y</mi><mn>1</mn></msub><mo>=</mo><msubsup><mo movablelimits="false">∫</mo><mn>0</mn><mi>T</mi></msubsup><mi>σ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐲</mi><mn>𝟏</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>+</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mi>n</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi></mrow></mtd></mtr></mtable></math>

> *Here any method can be used to solve the integral, like the Range-Kutta method or Euler discretization. The choice is left to the programmer*.

Ounce we get our output, the next logical step would be to define and utilise a Loss function. While the choice of losses is vast, I have used the most basic one: MSE or mean-squared error for simplicity. Let *L* be our loss function and *true* be our truth vector or label.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>=</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mi>n</mi></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>n</mi></mrow></msub></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>L</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>y</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo><mo>=</mo><msup><mrow><mo fence="true" form="prefix">(</mo><msub><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>0</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>1</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mn>2</mn></msub></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><msub><mi>r</mi><mi>n</mi></msub></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mn>1</mn><mo>* </mo><mi>n</mi></mrow></msub><mo>−</mo><msubsup><mo movablelimits="false">∫</mo><mn>0</mn><mi>T</mi></msubsup><mi>σ</mi><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐲</mi><mn>𝟏</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐲</mi><mi>𝐧</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center center center"><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>11</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mn>1</mn><mi>n</mi></mrow></msub></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>21</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mn>31</mn></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>⋱</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><mrow></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mn>1</mn></mrow></msub></mtd><mtd><mrow></mrow></mtd><mtd><mo>…</mo></mtd><mtd><mrow></mrow></mtd><mtd style="padding-right:0em;"><msub><mi>w</mi><mrow><mi>n</mi><mi>n</mi></mrow></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>+</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>1</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>2</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mn>3</mn></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>⋮</mi><mspace width="0pt" height="14.944pt"></mspace></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>b</mi><mi>n</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow><mi>d</mi><mi>t</mi><mo fence="true" form="postfix">)</mo></mrow><mn>2</mn></msup></mrow></mtd></mtr></mtable></math>

Now we need to get the gradient of the Output with respect to the loss, which can be very straightforward to calculate due to the simplistic nature of mean-squared error.

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><msub><mi>y</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mfrac><mrow><mi>d</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><msup><mo form="postfix" stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mi>d</mi><msub><mi>y</mi><mn>1</mn></msub></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><mn>2</mn><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>−</mo><msub><mi>y</mi><mn>1</mn></msub><mo form="postfix" stretchy="false">)</mo></mrow></math>

The next step is just the same as we discussed in the previous section: we backpropagate through integrating backwards in time. Remember that our Loss function is essentially takes in three parameters, the initial input *y<sub>0</sub>*, the time vector *t* and the function *f*, which defines the dynamics our input goes through. (In programming, the function passed in can be a class). This means we can calculate the gradients with respect to loss for each of these variables passed in, and would thus have to define an adjoint state for each one of them. Ounce we get the adjoint state, we find it's derivative with respect to time and integrate in order to get our final gradients (as was done in the theoritical section). In order to simplify the calculation and to avoid using the ODE solver again and again, we define an *augmented* state, which is just a vector made up of the variables of which we want a gradient of. We thus also define an *augmented adjoint* state, which will contain the adjoint dynamics of our variables.

<math display="block" class="tml-display" style="display:block math;"><mrow><mi>a</mi><mi>u</mi><mi>g</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>d</mi><mtext> </mtext><mi>s</mi><mi>t</mi><mi>a</mi><mi>t</mi><mi>e</mi><mo lspace="0.2222em" rspace="0.2222em">:</mo><mtext> </mtext><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mi>𝐲</mi></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mi>θ</mi></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mi>t</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></math>

How this state vector changes through time is governed by : 

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mi>d</mi><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>𝐲</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>=</mo><msub><mi>f</mi><mrow><mi>a</mi><mi>u</mi><mi>g</mi></mrow></msub><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>𝐲</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>t</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow><mo>=</mo><msub><mi>f</mi><mrow><mi>a</mi><mi>u</mi><mi>g</mi></mrow></msub><mrow><mo fence="true" form="prefix">(</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><mrow><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>𝟎</mn></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><mn>1</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo fence="true" form="postfix">)</mo></mrow></mrow></math>

The zero and one vector is because the time vector is differentiated with respect to time itself, and the parameters (θ), do not change during a forward pass. Following this result, we define an adjoint vector with the same properties :

<math display="block" class="tml-display" style="display:block math;"><mrow><msub><mi>𝐚</mi><mrow><mi>a</mi><mi>u</mi><mi>g</mi></mrow></msub><mo>=</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>y</mi></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>θ</mi></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>t</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo>=</mo><msup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>y</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mtd><mtd><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mtd><mtd style="padding-right:0em;"><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>t</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mi>T</mi></msup></mrow></math>

Another important equation is the derivative of the *f<sub>aug</sub>* with respect to our augmented vector: 

<math display="block" class="tml-display" style="display:block math;"><mrow><mfrac><mrow><mi>∂</mi><msub><mi>f</mi><mrow><mi>a</mi><mi>u</mi><mi>g</mi></mrow></msub></mrow><mrow><mi>∂</mi><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mi>𝐲</mi></mtd><mtd><mi>𝛉</mi></mtd><mtd style="padding-right:0em;"><mi>𝐭</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mfrac><mo>=</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐲</mi></mrow></mfrac></mtd><mtd><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝛉</mi></mrow></mfrac></mtd><mtd style="padding-right:0em;"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐭</mi></mrow></mfrac></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>𝟎</mn></mtd><mtd><mn>𝟎</mn></mtd><mtd style="padding-right:0em;"><mn>𝟎</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>𝟎</mn></mtd><mtd><mn>𝟎</mn></mtd><mtd style="padding-right:0em;"><mn>𝟎</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></math>

Going further, we simply get the derivative of the augmented adjoint state:

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>F</mi><mi>r</mi><mi>o</mi><mi>m</mi><mo separator="true">,</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>y</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>y</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mi>w</mi><mi>e</mi><mtext> </mtext><mi>g</mi><mi>e</mi><mi>t</mi><mo separator="true">,</mo></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><msub><mi>𝐚</mi><mrow><mi>a</mi><mi>u</mi><mi>g</mi></mrow></msub><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>d</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center"><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>y</mi></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>θ</mi></msub></mtd></mtr><mtr><mtd style="padding-left:0em;padding-right:0em;"><msub><mi>𝐚</mi><mi>t</mi></msub></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mi>T</mi></msup><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐲</mi></mrow></mfrac></mtd><mtd><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝛉</mi></mrow></mfrac></mtd><mtd style="padding-right:0em;"><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐭</mi></mrow></mfrac></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>𝟎</mn></mtd><mtd><mn>𝟎</mn></mtd><mtd style="padding-right:0em;"><mn>𝟎</mn></mtd></mtr><mtr><mtd style="padding-left:0em;"><mn>𝟎</mn></mtd><mtd><mn>𝟎</mn></mtd><mtd style="padding-right:0em;"><mn>𝟎</mn></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mo form="prefix" stretchy="false">−</mo><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center center"><mtr><mtd style="padding-left:0em;"><mrow><msub><mi>𝐚</mi><mi>y</mi></msub><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐲</mi></mrow></mfrac></mrow></mtd><mtd><mrow><msub><mi>𝐚</mi><mi>θ</mi></msub><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝛉</mi></mrow></mfrac></mrow></mtd><mtd style="padding-right:0em;"><mrow><msub><mi>𝐚</mi><mi>t</mi></msub><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝐭</mi></mrow></mfrac></mrow></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo></mrow></mtd></mtr></mtable></math>

> *The reason we derived the gradient of the output, y<sub>1</sub> with respect to loss (dL/dy<sub>1</sub>) is because it would be passed in the initial augmented state vector, to calculate the value of (dL/y<sub>0</sub>). Although this value may not be used.*

Since we do not need the first and final element in the output vector, we can simply ignore it. The first can be used to obtain the gradient with respect to the hidden states, the second can be used to obtain the gradient with respect to our parameters and the final is used to get the gradient with respect to the time vector. Let's focus on the second term, which describes the dynamics of the adjoint state of our parameters. Our final gradient for the parameters is obtained by integrating backwards in time, where we go from *T* to *0*.

<math display="block" class="tml-display" style="display:block math;"><mtable columnalign="left"><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>θ</mi></mrow></mfrac><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><msub><mi>t</mi><mi>N</mi></msub><mn>0</mn></msubsup><mi>a</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mfrac><mrow><mi>∂</mi><mo form="prefix" stretchy="false">(</mo><mi>f</mi><mo form="prefix" stretchy="false">(</mo><mi>h</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false">)</mo><mo separator="true">,</mo><mtext> </mtext><mi>t</mi><mo separator="true">,</mo><mtext> </mtext><msub><mi>θ</mi><mi>t</mi></msub><mo form="postfix" stretchy="false">)</mo><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><mi>T</mi><mn>0</mn></msubsup><msub><mi>𝐚</mi><mi>θ</mi></msub><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>𝛉</mi></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><mi>T</mi><mn>0</mn></msubsup><mfrac><mrow><mi>d</mi><mi>L</mi></mrow><mrow><mi>d</mi><mi>θ</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow></mfrac><mfrac><mrow><mi>∂</mi><mi>f</mi></mrow><mrow><mi>∂</mi><mi>θ</mi></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow></mrow></mtd></mtr><mtr><mtd class="tml-left" style="padding:0.5ex 0pt 0.5ex 0pt;"><mrow><mo>=</mo><mo form="prefix" stretchy="false">−</mo><msubsup><mo movablelimits="false">∫</mo><mi>T</mi><mn>0</mn></msubsup><mfrac><mrow><mi>d</mi><mo form="prefix" stretchy="false">(</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>−</mo><mi>σ</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>y</mi><mn>0</mn></msub><msub><mi>𝐖</mi><mrow><mi>n</mi><mo>*</mo><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>𝐁</mi><mrow><mn>1</mn><mo>*</mo><mi>n</mi></mrow></msub><mo form="postfix" stretchy="false">)</mo><msup><mo form="postfix" stretchy="false">)</mo><mn>2</mn></msup></mrow><mrow><mi>d</mi><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center"><mtr><mtd style="padding-left:0em;"><mi>𝐖</mi></mtd><mtd style="padding-right:0em;"><mi>𝐁</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mfrac><mfrac><mrow><mi>∂</mi><mi>σ</mi><mo form="prefix" stretchy="false">(</mo><msub><mi>y</mi><mn>0</mn></msub><msub><mi>𝐖</mi><mrow><mi>n</mi><mo>*</mo><mi>n</mi></mrow></msub><mo>+</mo><msub><mi>𝐁</mi><mrow><mn>1</mn><mo>*</mo><mi>n</mi></mrow></msub><mo form="postfix" stretchy="false" lspace="0em" rspace="0em">)</mo></mrow><mrow><mi>∂</mi><mrow><mo fence="true" form="prefix">[</mo><mtable columnalign="center center"><mtr><mtd style="padding-left:0em;"><mi>𝐖</mi></mtd><mtd style="padding-right:0em;"><mi>𝐁</mi></mtd></mtr></mtable><mo fence="true" form="postfix">]</mo></mrow></mrow></mfrac><mi>d</mi><mi>t</mi></mrow></mtd></mtr></mtable></math>

With this, we have finally found the gradient with respect to the parameters! Since there were a lot of equations, our primary focus of understanding the flow of inputs and gradients can be a little foggy. Here is the entire process, step by step to get a clearer understanding.

- Initiliase the time vector *t*, our input(s) *y<sub>0</sub>* and the function *f*.  (Here *f* can be anything, from RNNs, LSTMs to Transformers. It can even be entire model architectures).

- Apply the forward propagation method on the input *y<sub>0</sub>* to get to the output *y<sub>1</sub>*. Forward prop here is basically applying the function *T* times, and integrating the outputs. Here we make our first call to an ODE solver.

- Calculate the derivative of the loss with respect to the output (*dL/dy<sub>1</sub>*). This value will be passed in later in the adjoint state vector as the initial value to an integral.

- Define our augmented and adjoint augmented state vectors. (In code, this state was not defined explicitly, but was a part of the backward() call on the output, *y<sub>1</sub>*)

- Calculate the vector-jacobian products through the given adjoint equation. This equation gives us three adjoint dynamics, one with respect to the output/input, one with respect to our parameters used and one with respect to the time vector.

- Call our ODE solver for the second time in order to calculate the desired derivatves, with respect to the input function (*y(t)*), our parameters (*θ(t)*) and the time vector (*t(t)*). (*dL/y(t)*, *dL/θ(t)*, *dL/t(t)*).

- Update the weights and continue to iterate until desired loss function is achieved.

## Conclusion

Neural ODEs are sometimes also referred to as liquid neural networks. This method offers a different approach to solving problems for which neural networks were useful for. This method was quite popular when it came out in 2018 (It was awarded the best paper in NeurIPS) and yet failed to see adoption in mainstream models. There can be various reasons why this might've happened, one being this models (like SSMs) are more suited for continuous datasets, and can model data better when the underlying generator of data is continuous in nature. This architecture can also be viewed as a subset of a larger *Physics-Informed* neural networks, and I am hoping to explore this topic more! Thank you.

<p style="text-align: center;">
<strong><a href='/'>Home</a></strong>
</p>